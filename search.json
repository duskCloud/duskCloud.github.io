[{"title":"Sphere packings","path":"/2023/02/12/YadeTutorial/Sphere packings/","content":"Sphere packings通过球体排列来表示任意形状的固体存在球体堆积问题，即球体的空间排列使得给定的实体近似地填充它们。出于 DEM 仿真的目的，可能有几个要求。 球体半径的分布。任意体积可以完全填充球体，前提是它们的半径没有限制;在这种情况下，球体的数量可以是无限的，它们的半径接近于零。由于粒子数量和最小球体半径（通过临界时间步长）决定了计算成本，因此必须强制给出半径分布。最典型的分布是均匀的：均值±离散;如果色散为零，则所有球体将具有相同的半径。 平滑边界。一些算法处理边界的方式是球体在其上对齐，使它们作为表面更平滑。 堆积密度，或球体体积与固体尺寸之比。它与半径分布密切相关。 协调数，每个球体的（平均）触点数。 各向同性（与规律性&#x2F;不规则性有关）;通常不希望具有首选方向的填料，除非建模的实体也具有这种偏好。 允许球体的重叠;某些算法可能会在球体略微重叠的地方创建堆积;由于重叠通常会在DEM中产生力，因此无重叠填料有时被称为“无应力”。 Volume representation在Yade中，有两种方法可以表示所讨论的实体的精确体积：边界表示和构造实体几何。尽管它们存在根本差异，但它们在 Yade 中被抽象为 Predicate 类。 Predicate提供以下功能： 为关联的实体定义轴对齐的边界框（可选地定义定向边界框）; 可以决定给定点是在实体内部还是外部;大多数谓词还可以（精确或近似地）判断点是否在内部，并满足与所表示的实体边界的某个给定填充距离（因此该体积的球体不会从实体中伸出）。 Constructive Solid Geometry (CSG)CSG方法通过几何 基元(rimitives) 或原始实体（球体，圆柱体，盒子，圆锥体等）来描述体积 以及对它们的布尔运算。Yade中定义的基元包括 inCylinder, inSphere, inEllipsoid, sinHyperboloid, notInNotch.例如，用于拉伸压缩测试的hyperboloid （狗骨）试样可以这样构建（如img.img-hyperboloid_所示）： 1234567891011from yade import pack## construct the predicate firstpred=pack.inHyperboloid(centerBottom=(0,0,-.1),centerTop=(0,0,.1),radius=.05,skirt=.03)## alternatively: pack.inHyperboloid((0,0,-.1),(0,0,.1),.05,.03)## pack the predicate with spheres (will be explained later)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=3.5e-3)## add spheres to simulationO.bodies.append(spheres) Specimen constructed with the yade._packPredicates.inHyperboloid predicate, packed with yade.pack.randomDensePack. Boundary representation (BREP)通过边界表示实体比 CSG 体积灵活得多，但大多只是近似值。Yade与GNU三角化曲面库（GTS）接口，以导入GTS可读的曲面，但也可以从模拟脚本中显式构造它们。这使得相当复杂的形状的参数化构造成为可能;有一些函数可以从 2D 折线 (yade.pack.revolutionSurfaceMeridians) 创建一组 3D 折线，以在此类 3D 折线集 (yade.pack.sweptPolylines2gtsSurface). 之间对曲面进行三角测量。 例如，我们可以构建一个简单的漏斗 (examples/funnel.py, shown at img-funnel_):: 123456789101112131415161718192021from numpy import linspacefrom yade import pack# angles for points on circlesthetas=linspace(0,2*pi,num=16,endpoint=True)# creates list of polylines in 3d from list of 2d projections# turned from 0 to πmeridians=pack.revolutionSurfaceMeridians( [[(3+rad*sin(th),10*rad+rad*cos(th)) for th in thetas] for rad in linspace(1,2,num=10)], linspace(0,pi,num=10))# create surfacesurf=pack.sweptPolylines2gtsSurface( meridians +[[Vector3(5*sin(-th),-10+5*cos(-th),30) for th in thetas]] # add funnel top)# add to simulationO.bodies.append(pack.gtsSurface2Facets(surf)) Triangulated funnel, constructed with the examples/funnel.py script. GTS 曲面对象可用于下面两项： yade.pack.gtsSurface2Facets函数可在模拟中创建三角面(from Facet particles)，如例子漏斗所示.(三角面可直接由yade.ymport.stl从STL文件中导入) yade._packPredicates.inGtsSurface predicate can be created, 使用曲面作为封闭体积的边界表示。 The examples/gts-horse/gts-horse.py (img. img-horse_)显示了两种可能性;首先，导入几何和拓扑结构曲面： 12import gtssurf=gts.read(open(&#x27;horse.coarse.gts&#x27;)) 该面片对象用作packing的predicate： 1234pred=pack.inGtsSurface(surf)aabb=pred.aabb()radius=(aabb[1][0]-aabb[0][0])/40O.bodies.append(pack.regularHexa(pred,radius=radius,gap=radius/4.)) 然后，在平移后，作为模拟本身中三角化曲面的基础： 12surf.translate(0,0,-(aabb[1][2]-aabb[0][2]))O.bodies.append(pack.gtsSurface2Facets(surf,wire=True)) 导入GTS面(horse) 作为 packing predicate(top) 和由facets (bottom)组成的面See video for movie of this simulation. Boolean operations on predicates对predicates的bool运算 (注意 A 和 B) 定义如下: intersection A &amp; B (conjunction): 点必须在涉及的两个predicates中。 union A | B (disjunction): 点必须位于第一个predicate或第二个predicate中。 difference A - B (conjunction with second predicate negated): 点必须在第一个predicate中，而不是在第二个predicate中. symmetric difference A ^ B (exclusive disjunction): 点必须恰好位于两个predicates之一中。 组合 predicates 也需要正确定义边界框.例如，我们可以拿盒子并从内部移走圆柱体, 使用A - B 操作 (img. img-predicate-difference_):: 123pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,returnSpherePack=True)spheres.toSimulation() 盒子从内部取出圆柱体，使用这两个predicates的差异。 Packing algorithms下面介绍的算法在几何球体上运行，由其中心和半径定义。除下面记录的一些例外情况外，该过程如下： 计算球体位置和半径（有些函数为此使用volume predicate，有些则不使用） sphere 为每个位置和半径计算调用; 接收打包函数的额外关键字参数(keyword arguments)（即打包函数未在其定义中指定的参数;它们被记录为 **kw）。每个sphere调用都会创建具有球体形状的实际 Body 对象。返回 Body对象的列表。 从打包函数返回的列表可以使用toSimulation()”添加到模拟中。剩余代码使用了对O.bodies.append的调用。 以穿孔箱为例： 12pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,wire=True,color=(0,0,1),material=1,returnSpherePack=True) 关键字参数 wire, color 和material 未在 yade.pack.randomDensePack中声明, 因此将被传递到 sphere,并记录. spheres 现在是一个SpherePack对象:: 1spheres.toSimulation() 下面描述的包装算法会产生致密的填充。如果需要松散打包，SpherePack类通过其makeCloud() 方法提供用于生成松散打包的函数。它在内部用于在动态算法中生成初始配置。例如：： 123from yade import packsp=pack.SpherePack()sp.makeCloud(minCorner=(0,0,0),maxCorner=(3,3,3),rMean=.2,rRelFuzz=.5) 将用球体填充给定的框，直到无法放置更多球体。该对象可用于向模拟中添加球体： 1sp.toSimulation() Geometric几何算法计算packing，无需执行动态仿真;它们的优点包括： 速度; 球体完全接触，没有重叠（有些人称之为”stress-free” packing） 主要缺点是，除特定情况（常规填料）外，无法准确规定半径分布;球体半径由算法给出，该算法已经使系统确定。如果精确的半径分布对您的问题很重要，请考虑使用动态算法。 RegularYade为具有恒定半径的球体定义了packing生成器，可以与上述volume predicates一起使用。它们是密集的正交填料（yade.pack.regularOrtho）和致密的六边形填料（yade.pack.regularOrtho）。后者创造了所谓的“六边形紧密填料”，实现了最大的密度（http://en.wikipedia.org/wiki/Close-packing_of_spheres）。 常规填料的明显缺点是它们具有非常强烈的方向偏好，这在某些情况下可能不是问题。 Irregular随机几何算法不与上述volume predicates集成;相反，它们采用自己的边界&#x2F;体积定义，在球体定位期间使用。另一方面，这使得他们有可能重视边界，使球体在适当的位置接触边界，而不是在两者之间留下空白空间。GenGeo是使用 ESyS-Pparticle 开发的用于打包生成的库（python 模块）。它通过随机插入具有给定半径范围的球体来创建包装。插入的球体彼此精确地接触，更重要的是，如果在其附近，它们也会接触边界。边界表示为 GenGeo库的特殊对象（球体、圆柱体、盒子、凸多面体等…）。因此，GenGeo不能与如上所述由 yade predicates表示的volume一起使用。 该模块生成的Packings可以直接通过ymport.gengeo导入，也可以通过ymport.gengeoFile从保存的文件中导入。有一个示例脚本示例&#x2F;test&#x2F;genCylLSM.py。GenGeo的完整文档可以在 ESyS文档网站 上找到。 有 debian 软件包 esys-particle 和 python-demgengeo。 Dynamic随机密集包装的最通用算法由yade.pack.randomDensePack提供。非重叠球体的初始松散堆积是通过将它们随机放置在长方体体积中生成的，半径由请求的（目前仅均匀的）半径分布给出。当无法插入更多球体时，通过运行 DEM 模拟压缩填料，然后解压缩（有关这些“应力”的确切值，请参见py/pack/pack.py）; Omega.switchScene 用于不影响现有模拟）。最后，如上所述，使用提供的predicate裁剪生成的填料。 就其性质而言，此方法可能需要相对较长的时间;并且有2个规定可以缩短计算时间： 如果使用spheresInCell参数指定了球体数，则仅创建具有周期边界的较小样本，然后重复以填充predicate。这可以提供低规律性的高质量填料，具体取决于spheresInCell参数（建议值为几千）。 提供memoizeDb数将使yade.pack.randomDensePack首先查看提供的文件（SQLite数据库）以用于具有类似参数的包装。成功后，只需从数据库中读取包装并返回即可。如果没有类似的预先存在的打包，则运行正常过程，并在返回之前将结果保存在数据库中，以便具有相同参数的后续调用将快速返回。Providing memoizeDb parameter will make yade.pack.randomDensePack如果您需要获取完整的定期打包（而不是由predicate裁剪的打包），则可以使用yade.pack.randomPeriPack. 如有特殊需求，您可以“手工”自己制作包装。例如，包装边界可以从facets构建，让空间中随机定位的球体在重力作用下落下。","tags":["yade"]},{"title":"Setting Up A Simulation","path":"/2023/02/12/YadeTutorial/SettingUpASimulation/","content":"Setting up a simulation1Examples `gravity-deposition`, `oedometric-test`, `periodic-simple-shear`, `periodic-triaxial-test` deal with topics discussed here. Parametric studies模拟的输入参数 (such as size distribution, damping, various contact parameters, …) 影响结果, 但无法分析之间的关系。为了研究此类影响，可以运行只有几个参数的小型模拟。Yade可以运行 batch mode（批处理模式） 中, 一种可以联合 parameter table 的模拟脚本，可以在每次运行时修改特定参数. 批处理模拟无交互方式，用户无法介入; 用户必须明确模拟的开始和结束。 假定我们想研究 damping 对动能的影响。脚本需要调整以下几部分: 我们需要确保脚本能正确地从 parameter table 读取相关参数。通常使用yade.utils.readParamsFromTable；参数读取后会被yade.params.table创建为变量。 12readParamsFromTable(damping=.2) # yade.params.table.damping variable will be createdfrom yade.params import table # typing table.damping is easier than yade.params.table.damping Note that yade.utils.readParamsFromTable takes default values of its parameters, which are used if the script is not run in non-batch mode. 表格中的参数需要放在合适的地方 1NewtonIntegrator(damping=table.damping), 由于模拟没有交互，因此需要设置停止点:: 1234567O.engines+=[PyRunner(iterPeriod=1000,command=&#x27;checkUnbalancedForce()&#x27;)] # call our function defined below periodicallydef checkUnbalancedForce(): if unbalancedForce&lt;0.05: # exit Yade if unbalanced force drops below 0.05 plot.saveDataTxt(O.tags[&#x27;d.id&#x27;]+&#x27;.data.bz2&#x27;) # save all data into a unique file before exiting import sys sys.exit(0) # exit the program 最后，我们需要在脚本的最后设置模拟开始 12O.run() # run forever, until stopped by checkUnbalancedForce()waitIfBatch() # do not finish the script until the simulation ends; does nothing in non-batch mode parameter table 是简单的txt文件 (e.g. params.txt ), 其中一行指定一个模拟运行 comments start with # as in python damping # first non-comment line is variable name .2 .4 .6 最后，模拟需要使用特定的批处理命令运行 1user@machine:~\\$ yade-batch params.txt simulation.py Exercises Run the gravity-deposition script in batch mode, varying damping to take values of .2, .4, .6. See the http://localhost:9080 overview page while the batch is running (fig. imgBatchExample_). .. _imgBatchExample:.. image:: fig&#x2F;batch-example.png Boundary粒子在无限空间中运动，需要一些约束使得模拟有意义。 Supports到目前为止，supports(不可移动粒子)提供了必要的边界；在 gravity-deposition 脚本中，yade.geom.facetBox由facets(三角面元素)组成，并固定在空间中。facets由任意三角曲面组成(see relevant sections of the User&#39;s manual)；另一个经常使用的边界是yade.utils.wall（无限大轴向面） Periodic周期边界是使用周期(而不是无限)空间创建的“边界”。 这样的边界由 O.periodic=True激活, 空间构型由O.cell描述. 它非常适合于研究大块材料的行为，因为避免了边界效应，导致更小的颗粒数量。 另一方面，它可能不适合研究局部化，因为任何cell-level 效应(如剪切带)也必须满足周期性。 周期单元由其与全局轴对齐的box的reference size和current transformation描述，可捕获拉伸、剪切和旋转。变形是通过velocity gradient规定的，它在下一时间步模拟之前更新transformation 同向变形可使速度梯度在胞内涂抹，使边界溶解在整个胞内。Homothetic deformation 可使得 velocity gradient 在单元中改变， 使得边界在单元中分解. 应力和应变可以用PeriTriaxController控制; 可以使用PeriTriaxController.stressMask混合应力和应变全局状态 接下来创建周期型球状云并压缩，达到$\\sigma_x$&#x3D;-10 kPa, $\\sigma_y$&#x3D;-10kPa and $\\varepsilon _z$&#x3D;-0.1的状态。指定$x$和$y$的压力，stressMask二进制代码为0b011，即(x -&gt; 1, y -&gt; 2, z-&gt;4, in decimal 1+2&#x3D;3). 12345678910@suppressYade [1]: from yade import pack\tYade [1]: sp=pack.SpherePack()Yade [1]: sp.makeCloud((1,1,1),(2,2,2),rMean=.16,periodic=True)Yade [1]: sp.toSimulation() # implicitly sets O.periodic=True, and O.cell.refSize to the packing period sizeYade [1]: O.engines+=[PeriTriaxController(goal=(-1e4,-1e4,-.1),stressMask=0b011,maxUnbalanced=.2,doneHook=&#x27;functionToRunWhenFinished()&#x27;)] 当模拟运行时，PeriTriaxController接管控制，并在达到目标时调用doneHook。使用PeriTriaxController的完整模拟可能如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from __future__ import print_functionfrom yade import pack, plotsp = pack.SpherePack()rMean = .05sp.makeCloud((0, 0, 0), (1, 1, 1), rMean=rMean, periodic=True)sp.toSimulation()O.engines = [ ForceResetter(), InsertionSortCollider([Bo1_Sphere_Aabb()], verletDist=.05 * rMean), InteractionLoop([Ig2_Sphere_Sphere_ScGeom()], [Ip2_FrictMat_FrictMat_FrictPhys()], [Law2_ScGeom_FrictPhys_CundallStrack()]), NewtonIntegrator(damping=.6), PeriTriaxController( goal=(-1e6, -1e6, -.1), stressMask=0b011, maxUnbalanced=.2, doneHook=&#x27;goalReached()&#x27;, label=&#x27;triax&#x27;, maxStrainRate=(.1, .1, .1), dynCell=True ), PyRunner(iterPeriod=100, command=&#x27;addPlotData()&#x27;)]O.dt = .5 * utils.PWaveTimeStep()O.trackEnergy = Truedef goalReached():\tprint(&#x27;Goal reached, strain&#x27;, triax.strain, &#x27; stress&#x27;, triax.stress)\tO.pause()def addPlotData():\tplot.addData( sx=triax.stress[0], sy=triax.stress[1], sz=triax.stress[2], ex=triax.strain[0], ey=triax.strain[1], ez=triax.strain[2], i=O.iter, unbalanced=utils.unbalancedForce(), totalEnergy=O.energy.total(), **O.energy # plot all energies\t)plot.plots = &#123; &#x27;i&#x27;: ((&#x27;unbalanced&#x27;, &#x27;go&#x27;), None, &#x27;kinetic&#x27;), &#x27; i&#x27;: (&#x27;ex&#x27;, &#x27;ey&#x27;, &#x27;ez&#x27;, None, &#x27;sx&#x27;, &#x27;sy&#x27;, &#x27;sz&#x27;), &#x27;i &#x27;: (O.energy.keys, None, (&#x27;totalEnergy&#x27;, &#x27;bo&#x27;))&#125;plot.plot()O.saveTmp()O.run()","tags":["yade"]},{"title":"Scene Construction","path":"/2023/02/12/YadeTutorial/SceneConstruction/","content":"Adding particles在模拟中，BodyContainer保存 Body 对象; 通过O.bodies访问。 Creating Body objectsBody很少由直接组件构成(如Shape, Bound, State, Material)，作为替代，一些便捷函数（如sphere, facet 和 wall）可以用来生成Body。如果Body的内部结构发生了某种变化，那么使用这些函数还可以确保更好的未来兼容性。这些函数接收粒子的几何形状和其他一些特征。通过它们的文档获取更多细节。如果相同的Material 用于多个(或多个)物体，可以通过将其添加到O.materials中来共享，如下所述。 Defining materialsO.materials对象(如Omega.materials)可以保存为 bodies 定义的共享材料.它只支持附加，并且通常只包含少数实例(尽管没有限制)。 给每个材料的label是可选的，也可以传递给sphere和其他功能，以构建Body。由O.materials.append返回的值是材质的id，它也可以传递给sphere—它比使用label稍微快一些，但是对于少量的粒子来说并不明显，而且可能不太方便。 如果在调用sphere时没有指定Material，则使用最后定义的Material;这是一个方便的默认。如果还没有定义材质(因此没有最后一个材质)，将创建一个Material(density&#x3D; 13e3,young&#x3D;1e7,poisson&#x3D;.3,frictionAngle&#x3D;.5)。这在正式的模拟中不应该发生，但在简单的脚本中很方便，因为确切的材料属性或多或少是无关紧要的。 12345678910111213141516171819202122232425262728@suppressYade [0]: O.reset()Yade [1]: len(O.materials)Yade [2]: idConcrete=O.materials.append(FrictMat(young=30e9,poisson=.2,frictionAngle=.6,label=&quot;concrete&quot;))Yade [3]: O.materials[idConcrete]# uses the last defined materialYade [3]: O.bodies.append(sphere(center=(0,0,0),radius=1))# material given by idYade [4]: O.bodies.append(sphere((0,0,2),1,material=idConcrete))# material given by labelYade [5]: O.bodies.append(sphere((0,2,0),1,material=&quot;concrete&quot;))Yade [3]: idSteel=O.materials.append(FrictMat(young=210e9,poisson=.25,frictionAngle=.8,label=&quot;steel&quot;))Yade [7]: len(O.materials)# implicitly uses &quot;steel&quot; material, as it is the last one nowYade [6]: O.bodies.append(facet([(1,0,0),(0,1,0),(-1,-1,0)])) Adding multiple particles如上所示,通过append方法同时添加一个或多个实体（Body）。 12345678910111213@suppressYade [0]: O.reset()Yade [1]: O.bodies.append(sphere((0,10,0),1))Yade [2]: O.bodies.append(sphere((0,0,2),1))# this is the same, but in one function callYade [3]: O.bodies.append([\t...: sphere((0,0,0),1),\t...: sphere((1,1,3),1)\t...: ]) 下一节介绍的许多函数返回可以随时添加到模拟中的实体列表，包括 packing generators, such as yade.pack.randomDensePack, yade.pack.regularHexa surface function yade.pack.gtsSurface2Facets import functions yade.ymport.gmsh, yade.ymport.stl, … 由于这些函数在内部使用sphere和facet，它们接受传递给这些函数的附加参数。特别地，每个主体的材料都是按照上面的规则选择的(如果没有指定最后一个，按标签，按索引等)。 Clumping particles together (聚集颗粒块？)在某些情况下，您可能想要创建一类粒子的刚性聚合(即粒子将在模拟过程中保持它们的相互位置)。我们将其称为clump。Clump由一个特殊的Body和成员引用clumpId组成(也可以看 isClump, isClumpMember and isStandalone) 。和Body一样，clump也有position，所有成员间的质点。 clump自身和其他实体之间没有interactions。clumps之间的相互作用由clump members之间的相互作用表示。同一个clump中的成员之间没有相互作用。（也就是，clump与clump之间的相互作用由两个clump分别由两个numbers的的相互作用组成） YADE 支持以不同的方式创建clump： 直接通过命令创建 clumps 和 spheres函数 appendClumped() 就是为这个任务设计的。例如，我们可以把两个球连在一起: 12345678910111213@suppressYade [0]: O.reset()Yade [1]: O.bodies.appendClumped([\t...: sphere([0,0,0],1),\t...: sphere([0,0,2],1)\t...: ])Yade [2]: len(O.bodies)Yade [3]: O.bodies[1].isClumpMember, O.bodies[2].clumpIdYade [2]: O.bodies[2].isClump, O.bodies[2].clumpId -&gt; appendClumped() 返回一个 tuple of ids (clumpId,[memberId1,memberId2,...]) 使用现有球体并将它们聚集在一起： 对于这个粒子函数clump()可将现存的boyd加入一个List。For this case the function clump() can be applied on a list of existing bodies: 123456789101112@suppressYade [0]: O.reset()Yade [1]: bodyList = []Yade [2]: for ii in range(0,5): ...: bodyList.append(O.bodies.append(sphere([ii,0,1],.5)))#create a &quot;chain&quot; of 5 spheres ...:Yade [3]: print(bodyList)Yade [4]: idClump=O.bodies.clump(bodyList) -&gt; clump() 返回 clumpId 另一种选择是使用clump模板将给定packing中的standalone spheres (see SpherePack and makeCloud)替换为clump 这是通过一个名为replacebyclups()的函数来完成的。这个函数接受一个cluptemplates()列表和一个总列表，并将spheres替换为clump。新clump的体积将与被替换的sphere的体积相同(clump的体积&#x2F;质量&#x2F;惯性将考虑重叠，假设只有一对重叠)。 -&gt; replaceByClumps() returns a list of tuples: [(clumpId1,[memberId1,memberId2,...]),(clumpId2,[memberId1,memberId2,...]),...] 该函数可以向一个clump中添加（add）或释放（release）实体。也可以擦除(erase)这个clump（clump内的numbers会被解散成独立的实体）。 此外，YADE允许对一个clump实现roundness或者一个packing的roundness coefficient。packing的某些部分可以通过排除列表从roundness measurement 中排除。 1234567891011121314@suppressYade [0]: O.reset()Yade [1]: bodyList = []Yade [2]: for ii in range(1,5):\t...: bodyList.append(O.bodies.append(sphere([ii,ii,ii],.5)))\t...:Yade [4]: O.bodies.clump(bodyList)Yade [5]: RC=O.bodies.getRoundness()Yade [3]: print(RC) -&gt; getRoundness()返回一个 roundness coefficient RC of a packing or a part of the packing Have a look at examples/clumps/ folder. There you will find some examples, that show usage of different functions for clumps. Sphere packings通过球体排列来表示任意形状的固体存在球体堆积问题，即球体的空间排列使得给定的实体近似地填充它们。出于 DEM 仿真的目的，可能有几个要求。 球体半径的分布。任意体积可以完全填充球体，前提是它们的半径没有限制;在这种情况下，球体的数量可以是无限的，它们的半径接近于零。由于粒子数量和最小球体半径（通过临界时间步长）决定了计算成本，因此必须强制给出半径分布。最典型的分布是均匀的：均值±离散;如果色散为零，则所有球体将具有相同的半径。 平滑边界。一些算法处理边界的方式是球体在其上对齐，使它们作为表面更平滑。 堆积密度，或球体体积与固体尺寸之比。它与半径分布密切相关。 协调数，每个球体的（平均）触点数。 各向同性（与规律性&#x2F;不规则性有关）;通常不希望具有首选方向的填料，除非建模的实体也具有这种偏好。 允许球体的重叠;某些算法可能会在球体略微重叠的地方创建堆积;由于重叠通常会在DEM中产生力，因此无重叠填料有时被称为“无应力”。 Volume representation在Yade中，有两种方法可以表示所讨论的实体的精确体积：边界表示和构造实体几何。尽管它们存在根本差异，但它们在 Yade 中被抽象为 Predicate 类。 Predicate提供以下功能： 为关联的实体定义轴对齐的边界框（可选地定义定向边界框）; 可以决定给定点是在实体内部还是外部;大多数谓词还可以（精确或近似地）判断点是否在内部，并满足与所表示的实体边界的某个给定填充距离（因此该体积的球体不会从实体中伸出）。 Constructive Solid Geometry (CSG)CSG方法通过几何 基元(rimitives) 或原始实体（球体，圆柱体，盒子，圆锥体等）来描述体积 以及对它们的布尔运算。Yade中定义的基元包括 inCylinder, inSphere, inEllipsoid, sinHyperboloid, notInNotch.例如，用于拉伸压缩测试的hyperboloid （狗骨）试样可以这样构建（如img.img-hyperboloid_所示）： 1234567891011from yade import pack## construct the predicate firstpred=pack.inHyperboloid(centerBottom=(0,0,-.1),centerTop=(0,0,.1),radius=.05,skirt=.03)## alternatively: pack.inHyperboloid((0,0,-.1),(0,0,.1),.05,.03)## pack the predicate with spheres (will be explained later)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=3.5e-3)## add spheres to simulationO.bodies.append(spheres) Specimen constructed with the yade._packPredicates.inHyperboloid predicate, packed with yade.pack.randomDensePack. Boundary representation (BREP)通过边界表示实体比 CSG 体积灵活得多，但大多只是近似值。Yade与GNU三角化曲面库（GTS）接口，以导入GTS可读的曲面，但也可以从模拟脚本中显式构造它们。这使得相当复杂的形状的参数化构造成为可能;有一些函数可以从 2D 折线 (yade.pack.revolutionSurfaceMeridians) 创建一组 3D 折线，以在此类 3D 折线集 (yade.pack.sweptPolylines2gtsSurface). 之间对曲面进行三角测量。 例如，我们可以构建一个简单的漏斗 (examples/funnel.py, shown at img-funnel_):: 123456789101112131415161718192021from numpy import linspacefrom yade import pack# angles for points on circlesthetas=linspace(0,2*pi,num=16,endpoint=True)# creates list of polylines in 3d from list of 2d projections# turned from 0 to πmeridians=pack.revolutionSurfaceMeridians( [[(3+rad*sin(th),10*rad+rad*cos(th)) for th in thetas] for rad in linspace(1,2,num=10)], linspace(0,pi,num=10))# create surfacesurf=pack.sweptPolylines2gtsSurface( meridians +[[Vector3(5*sin(-th),-10+5*cos(-th),30) for th in thetas]] # add funnel top)# add to simulationO.bodies.append(pack.gtsSurface2Facets(surf)) Triangulated funnel, constructed with the examples/funnel.py script. GTS 曲面对象可用于下面两项： yade.pack.gtsSurface2Facets函数可在模拟中创建三角面(from Facet particles)，如例子漏斗所示.(三角面可直接由yade.ymport.stl从STL文件中导入) yade._packPredicates.inGtsSurface predicate can be created, 使用曲面作为封闭体积的边界表示。 The examples/gts-horse/gts-horse.py (img. img-horse_)显示了两种可能性;首先，导入几何和拓扑结构曲面： 12import gtssurf=gts.read(open(&#x27;horse.coarse.gts&#x27;)) 该面片对象用作packing的predicate： 1234pred=pack.inGtsSurface(surf)aabb=pred.aabb()radius=(aabb[1][0]-aabb[0][0])/40O.bodies.append(pack.regularHexa(pred,radius=radius,gap=radius/4.)) 然后，在平移后，作为模拟本身中三角化曲面的基础： 12surf.translate(0,0,-(aabb[1][2]-aabb[0][2]))O.bodies.append(pack.gtsSurface2Facets(surf,wire=True)) 导入GTS面(horse) 作为 packing predicate(top) 和由facets (bottom)组成的面See video for movie of this simulation. Boolean operations on predicates对predicates的bool运算 (注意 A 和 B) 定义如下: intersection A &amp; B (conjunction): 点必须在涉及的两个predicates中。 union A | B (disjunction): 点必须位于第一个predicate或第二个predicate中。 difference A - B (conjunction with second predicate negated): 点必须在第一个predicate中，而不是在第二个predicate中. symmetric difference A ^ B (exclusive disjunction): 点必须恰好位于两个predicates之一中。 组合 predicates 也需要正确定义边界框.例如，我们可以拿盒子并从内部移走圆柱体, 使用A - B 操作 (img. img-predicate-difference_):: 123pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,returnSpherePack=True)spheres.toSimulation() 盒子从内部取出圆柱体，使用这两个predicates的差异。 Packing algorithms下面介绍的算法在几何球体上运行，由其中心和半径定义。除下面记录的一些例外情况外，该过程如下： 计算球体位置和半径（有些函数为此使用volume predicate，有些则不使用） sphere 为每个位置和半径计算调用; 接收打包函数的额外关键字参数(keyword arguments)（即打包函数未在其定义中指定的参数;它们被记录为 **kw）。每个sphere调用都会创建具有球体形状的实际 Body 对象。返回 Body对象的列表。 从打包函数返回的列表可以使用toSimulation()”添加到模拟中。剩余代码使用了对O.bodies.append的调用。 以穿孔箱为例： 12pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,wire=True,color=(0,0,1),material=1,returnSpherePack=True) 关键字参数 wire, color 和material 未在 yade.pack.randomDensePack中声明, 因此将被传递到 sphere,并记录. spheres 现在是一个SpherePack对象:: 1spheres.toSimulation() 下面描述的包装算法会产生致密的填充。如果需要松散打包，SpherePack类通过其makeCloud() 方法提供用于生成松散打包的函数。它在内部用于在动态算法中生成初始配置。例如：： 123from yade import packsp=pack.SpherePack()sp.makeCloud(minCorner=(0,0,0),maxCorner=(3,3,3),rMean=.2,rRelFuzz=.5) 将用球体填充给定的框，直到无法放置更多球体。该对象可用于向模拟中添加球体： 1sp.toSimulation() Geometric几何算法计算packing，无需执行动态仿真;它们的优点包括： 速度; 球体完全接触，没有重叠（有些人称之为”stress-free” packing） 主要缺点是，除特定情况（常规填料）外，无法准确规定半径分布;球体半径由算法给出，该算法已经使系统确定。如果精确的半径分布对您的问题很重要，请考虑使用动态算法。 RegularYade为具有恒定半径的球体定义了packing生成器，可以与上述volume predicates一起使用。它们是密集的正交填料（yade.pack.regularOrtho）和致密的六边形填料（yade.pack.regularOrtho）。后者创造了所谓的“六边形紧密填料”，实现了最大的密度（http://en.wikipedia.org/wiki/Close-packing_of_spheres）。 常规填料的明显缺点是它们具有非常强烈的方向偏好，这在某些情况下可能不是问题。 Irregular随机几何算法不与上述volume predicates集成; 相反，它们采用自己的边界&#x2F;体积定义，在球体定位期间使用。另一方面，这使得他们有可能重视边界，使球体在适当的位置接触边界，而不是在两者之间留下空白空间。GenGeo是使用 ESyS-Pparticle 开发的用于打包生成的库（python 模块）。它通过随机插入具有给定半径范围的球体来创建包装。插入的球体彼此精确地接触，更重要的是，如果在其附近，它们也会接触边界。边界表示为 GenGeo库的特殊对象（球体、圆柱体、盒子、凸多面体等…）。因此，GenGeo不能与如上所述由 yade predicates表示的volume一起使用。 该模块生成的Packings可以直接通过ymport.gengeo导入，也可以通过ymport.gengeoFile从保存的文件中导入。有一个示例脚本示例&#x2F;test&#x2F;genCylLSM.py。GenGeo的完整文档可以在 ESyS文档网站 上找到。 有 debian 软件包 esys-particle 和 python-demgengeo。 Dynamic随机密集包装的最通用算法由yade.pack.randomDensePack提供。非重叠球体的初始松散堆积是通过将它们随机放置在长方体体积中生成的，半径由请求的（目前仅均匀的）半径分布给出。当无法插入更多球体时，通过运行 DEM 模拟压缩填料，然后解压缩（有关这些“应力”的确切值，请参见py/pack/pack.py）; Omega.switchScene 用于不影响现有模拟）。最后，如上所述，使用提供的predicate裁剪生成的填料。 就其性质而言，此方法可能需要相对较长的时间;并且有2个规定可以缩短计算时间： 如果使用spheresInCell参数指定了球体数，则仅创建具有周期边界的较小样本，然后重复以填充predicate。这可以提供低规律性的高质量填料，具体取决于spheresInCell参数（建议值为几千）。 提供memoizeDb数将使yade.pack.randomDensePack首先查看提供的文件（SQLite数据库）以用于具有类似参数的包装。成功后，只需从数据库中读取包装并返回即可。如果没有类似的预先存在的打包，则运行正常过程，并在返回之前将结果保存在数据库中，以便具有相同参数的后续调用将快速返回。Providing memoizeDb parameter will make yade.pack.randomDensePack如果您需要获取完整的定期打包（而不是由predicate裁剪的打包），则可以使用yade.pack.randomPeriPack. 如有特殊需求，您可以“手工”自己制作包装。例如，包装边界可以从facets构建，让空间中随机定位的球体在重力作用下落下。","tags":["yade"]},{"title":"Hand on","path":"/2023/02/12/YadeTutorial/Hand_on/","content":"Shell 基础文件树目录树是在操作系统中组织文件的分层方式。Linux 中典型的文件(简化)树如下所示： 12345678910111213141516171819202122/ Root├──boot System startup├──bin Low-level programs├──lib Low-level libraries├──dev Hardware access├──sbin Administration programs├──proc System information├──var Files modified by system services├──root Root (administrator) home directory├──etc Configuration files├──media External drives├──tmp Temporary files├──usr Everything for normal operation (usr = UNIX system resources)│ ├──bin User programs│ ├──sbin Administration programs│ ├──include Header files for c/c++│ ├──lib Libraries│ ├──local Locally installed software│ └──doc Documentation└──home Contains the user&#x27;s home directories ├──user Home directory for user └──user1 Home directory for user1 注意这里只有一个单独的树；其他硬盘(例如U盘)挂载在树中的一点下(如&#x2F;media)。 Shell 导航Shell是Unix的命令行用以与系统交互。 Don’t be afraid. 移动可以通过Shell在文件树中移动 12345678910user@machine:~$ # user operating at machine, in the directory ~ (= user&#x27;s home directory)user@machine:~$ ls . # list contents of the current directoryuser@machine:~$ ls foo # list contents of directory foo, relative to the dcurrent directory ~ (= ls ~/foo = ls /home/user/foo)user@machine:~$ ls /tmp # list contents of /tmpuser@machine:~$ cd foo # change directory to foouser@machine:~/foo$ ls ~ # list home directory (= ls /home/user)user@machine:~/foo$ cd bar # change to bar (= cd ~/foo/bar)user@machine:~/foo/bar$ cd ../../foo2 # go to the parent directory twice, then to foo2 (cd ~/foo/bar/../../foo2 = cd ~/foo2 = cd /home/user/foo2)user@machine:~/foo2$ cd # go to the home directory (= ls ~ = ls /home/user)user@machine:~$ 通常，用户在其文件夹中具有读写权限，如 &#x2F;home&#x2F;user和&#x2F;tmp，也可以读取系统中其他大部分文件。 12user@machine:~$ ls /root # see what files the administrator hasls: cannot open directory /root: Permission denied 按键常用按键如下: 按键 作用 &lt;tab&gt; 显示可补全的内容 ^C (&#x3D;Ctrl+C) 删除当前行 ^D 退出Shell ↑↓ 在命令行历史记录中移动 ^C 打断当前正在运行的程序 ^\\ 杀死当前运行的程序 Shift-PgUp 向上滚动屏幕 Shift-PgDown 向下滚动屏幕 运行程序当运行一个没有给出完整路径的程序时，系统会在$PATH中搜索。 123user@machine:~$ echo $PATH # show the value of $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/gamesuser@machine:~$ which ls # say what is the real path of ls Python 基础Yade 基础Yade对象通过实例化创建，如以下方式。 1234567891011121314151617Yade [36]: Sphere # try also Sphere?Out[36]: yade.wrapper.SphereYade [37]: s=Sphere() # create a Sphere, without specifying any attributesYade [38]: s.radius # &#x27;nan&#x27; is a special value meaning &quot;not a number&quot; (i.e. not defined)Out[38]: nanYade [39]: s.radius=2 # set radius of an existing objectYade [40]: s.radiusOut[40]: 2.0Yade [41]: ss=Sphere(radius=3) # create Sphere, giving radius directlyYade [42]: s.radius, ss.radius # also try typing s.&lt;tab&gt; to see defined attributesOut[42]: (2.0, 3.0) Particles 粒子Particles 是用以模拟的data对象，它们会经历一些过程，虽然现在还没有定义。 单个粒子创建有许多预定义的函数用来创建某些类型的粒子；为创建一个sphere球体，需要: Create Body 创建一个Body Set Body.shape to be an instance of Sphere with some given radius 通过一些参数设置Body形状 Set Body.material 设置Body材料，使用最后一次创建的材料，否则使用默认材料 在Body.state 中设置位置和方向状态，根据材料和形状计算质量和惯性矩.为避免繁琐创建，Yade提供简化函数。如utils.sphere，utils.facet，utils.wall。1234567891011121314151617Yade [43]: s=utils.sphere((0,0,0),radius=1) # create sphere particle centered at (0,0,0) with radius=1Yade [44]: s.shape # s.shape describes the geometry of the particleOut[44]: &lt;Sphere instance at 0x339d650&gt;Yade [45]: s.shape.radius # we already know the Sphere classOut[45]: 1.0Yade [46]: s.state.mass, s.state.inertia # inertia is computed from density and geometryOut[46]: (4188.790204786391, Vector3(1675.516081914556253,1675.516081914556253,1675.516081914556253))Yade [47]: s.state.pos # position is the one we prescribedOut[47]: Vector3(0,0,0)Yade [48]: s2=utils.sphere((-2,0,0),radius=1,fixed=True) # explanation below 在最后一个语句中，粒子通过utils.shpere的参数fixed固定在空间中以防止移动，进而构成初始边界条件。粒子对象并不是模拟的全部，进行下一步还需要调用一个特殊的函数O.bodies.append12Yade [49]: O.bodies.append(s) # adds particle s to the simulation; returns id of the particle(s) addedOut[49]: 24 Packs在pack模块中有用以生成特殊粒子序列的函数；例如，粒子云可由 pack.SpherePack类生成 1234567891011121314151617181920Yade [50]: from yade import packYade [51]: sp=pack.SpherePack() # create an empty cloud; SpherePack contains only geometrical informationYade [52]: sp.makeCloud((1,1,1),(2,2,2),rMean=.2) # put spheres with defined radius inside box given by corners (1,1,1) and (2,2,2)Out[52]: 8Yade [53]: for c,r in sp: print(c,r) # print center and radius of all particles (SpherePack is a sequence which can be iterated over) ....: Vector3(1.577889023765002285,1.721224540149461912,1.296535996507017785) 0.2Vector3(1.688464584622245024,1.72322752536125523,1.717122284573653346) 0.2Vector3(1.218405499935725445,1.358570888863975368,1.796451085857081686) 0.2Vector3(1.270974198229762209,1.743076120666066098,1.610130651546826108) 0.2Vector3(1.791018110292273091,1.386492344860074333,1.398521108729773754) 0.2Vector3(1.246175170816176347,1.211920867632996668,1.387296344351888422) 0.2Vector3(1.202324092218342244,1.585345529527522945,1.238712690496557522) 0.2Vector3(1.687446180906541082,1.268340543912729546,1.772108090509637135) 0.2Yade [54]: sp.toSimulation() # create particles and add them to the simulationOut[54]: [25, 26, 27, 28, 29, 30, 31, 32] Boundaries 边界utils.facet (三角面) 和 utils.wall(无限的平面) 通常用来定义边界。例如，在模拟中创建一个地板floor如下： 12Yade [55]: O.bodies.append(utils.wall(-1,axis=2))Out[55]: 33 查看内部可通过多种方式检查模拟，所有数据可由Python直径访问。 12345678Yade [56]: len(O.bodies)Out[56]: 34Yade [57]: O.bodies[10].shape.radius # radius of body #10 (will give error if not sphere, since only spheres have radius defined)Out[57]: 0.16Yade [58]: O.bodies[12].state.pos # position of body #12Out[58]: Vector3(1.000320911443931315,1.550796011829636667,1.421621448908745755) 此外，Yade在启动时(命令行之前) 1[[ ^L clears screen, ^U kills line. F12 controller, F11 3d view, F10 both, F9 generator, F8 plot. ]] Controller:按下F12可出现控制模拟的窗口。尽管在大型模拟中通常不会进行人工干预(这些模拟是“无头”运行的，没有任何图形交互)，但在小示例中这很方便。这里有关于模拟的基本信息(将在后面使用)。3d view : 3d视图可以用F11打开(或者点击控制器中的按钮-见下文)。有许多快捷键可以操作它(按h键可以获得基本帮助)，并且可以使用鼠标移动、旋转和缩放它。可以在控制器的“Display”选项卡中设置显示相关的设置(例如是否绘制粒子)。练习 下面代码的运行状态12Yade [59]: O.bodies.append([utils.sphere((2*i,0,0),1) for i in range(1,20)])Out[59]: [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52] 在封闭的box(0,0,0)(1,1,1)中创建简单的平均半径为.1的球体粒子云模拟(提示：pack.SpherePack.makeCloud) 将上述创建的粒子云放于上端开口的box(0,0,0)(1,1,1)中(提示： utils.facetBox; type utils.facetBox? or utils.facetBox?? to get help on the command line) (新版本已丢弃？译者使用gemo.facetBox) 打开3D视图，尝试放大&#x2F;缩小;定位坐标轴，使z向上，y向右，x向你。 Engines 引擎Engines定义了由粒子进行的过程。从理论介绍中我们知道，Engines的序列称为模拟循环。让我们定义一个简单的交互循环: 123456789101112131415161718192021222324Yade [60]: O.engines=[ # newlines and indentations are not important until the brace is closed ....: ForceResetter(), ....: InsertionSortCollider([Bo1_Sphere_Aabb(),Bo1_Wall_Aabb()]), ....: InteractionLoop( # dtto for the parenthesis here ....: [Ig2_Sphere_Sphere_ScGeom(),Ig2_Wall_Sphere_ScGeom()], ....: [Ip2_FrictMat_FrictMat_FrictPhys()], ....: [Law2_ScGeom_FrictPhys_CundallStrack()] ....: ), ....: NewtonIntegrator(damping=.2,label=&#x27;newtonCustomLabel&#x27;) # define a label newtonCustomLabel under which we can access this engine easily ....: ] ....: Yade [61]: O.enginesOut[61]: [&lt;ForceResetter instance at 0x3286640&gt;, &lt;InsertionSortCollider instance at 0x33f8300&gt;, &lt;InteractionLoop instance at 0x320d4d0&gt;, &lt;NewtonIntegrator instance at 0x20d9cb0&gt;]Yade [62]: O.engines[-1]==newtonCustomLabel # is it the same object? 引擎名称Out[62]: TrueYade [63]: newtonCustomLabel.dampingOut[63]: 0.2 我们可以在文件(脚本)中描述模拟，然后以该文件作为参数运行yade，而不是将所有内容都输入到命令行中。因此，除非必要，否则我们将不再显示命令行;相反，只显示脚本部分。如下: 1234567891011O.engines=[ # newlines and indentations are not important until the brace is closed ForceResetter(), InsertionSortCollider([Bo1_Sphere_Aabb(),Bo1_Wall_Aabb()]), InteractionLoop( # dtto for the parenthesis here [Ig2_Sphere_Sphere_ScGeom(),Ig2_Wall_Sphere_ScGeom()], [Ip2_FrictMat_FrictMat_FrictPhys()], [Law2_ScGeom_FrictPhys_CundallStrack()] ), GravityEngine(gravity=(0,0,-9.81)), # 9.81 is the gravity acceleration, and we say that NewtonIntegrator(damping=.2,label=&#x27;newtonCustomLabel&#x27;) # define a label under which we can access this engine easily] 除了正在运行的Engines，定义它们运行的频率也同样重要。有些Engines只能运行一段时间(我们将在后面看到)，而大多数Engines将始终运行;两次连续运行Engines之间的时间是时间步(Δt)。在时间步长的数值上有一个数学限制，称为临界时间步长，它是由粒子的性质计算出来的。由于有相应的函数，我们可以使用utils.PWaveTimeStep设置时间步长: 1O.dt=utils.PWaveTimeStep() 每次模拟循环结束时，时间O.time向前移动时间步长O.dt: 123456789Yade [64]: O.dt=0.01Yade [65]: O.timeOut[65]: 0.0Yade [66]: O.step()Yade [67]: O.timeOut[67]: 0.01 联系 如上图所示定义引擎，运行检查器并单击引擎以查看它们的顺序。 编写一个简单的脚本 像前面练习中那样定义粒子(从顶部打开的盒子内的球体云) 定义一个简单的模拟循环，如上所述 设置Δt等于临界p波Δt 将初始模拟状态保存到内存中 多次运行前面定义的模拟，同时更改timestep的值(使用⟳按钮重新加载初始配置)。 看看在p波值以上增加Δt会发生什么。 在运行模拟之前，尝试更改重力参数。 试着改变阻尼 重新加载模拟，打开3d视图，打开Inspector，在3d视图中选择一个粒子(shift-click)。然后运行模拟，观察作用在粒子上的力是如何变化的;在中间的某个地方暂停模拟，看看这个粒子的相互作用。 到什么时候我们才能说沉积已经完成，这样模拟就可以停止了?","tags":["yade"]},{"title":"Data mining","path":"/2023/02/12/YadeTutorial/dataMining/","content":"Data miningReadLocal data所有的模拟数据均可由python访问;当你打开Inspector 时,蓝色标签内的数据可以被点击–左键跳转到文档，中键复制对象名称（使用Ctrl-v或中键点击复制到其他地方),其中有一些有趣的东西(see Omega for a full list). O.engines在模拟循环中，Engines 通过其index访问 12O.engines[0] # first engineO.engines[-1] # last engine 注意::O.engines被修改后,其index也会改变. 下面一节介绍的Labeling是可靠访问特定engines的更好解决方案。 O.bodies 通过id识别Bodies, 并保证id在整个模拟过程中不会改变。 1234O.bodies[0] # first body[b.shape.radius for b in O.bodies if isinstance(b.shape,Sphere)] # list of radii of all spherical bodiessum([b.state.mass for b in O.bodies]) # sum of masses of all bodiesnumpy.average([b.state.vel[0] for b in O.bodies]) # average velocity in x direction 注意:: 并不能保证 Body.id的唯一性,因为新创建的Body可能会使用之前被删除Body的id。 O.forces 作用在每个粒子上的广义力(力，力矩)。它们(通常)在每一步的开始用ForceResetter重置，随后来自个别交互的力在InteractionLoop中积累。要访问数据，请使用: 12O.forces.f(0) # force on #0O.forces.t(1) # torque on #1 O.interactions 相互作用通过各自相互作用粒子的id来识别(它们在模拟过程中自动创建和删除): 12345O.interactions[0,1] # interactions of #0 with #1O.interactions[1,0] # the same objectO.bodies[0].intrs() # all interactions of body #0for i in O.bodies[12].intrs(): print (i.isReal,i.id1,i.id2) # get some info about interactions of body #12[(i.isReal,i.id1,i.id2) for i in O.bodies[12].intrs()] # same thing, but make a list LabelsEngines and functors 可以被标记(labeled), 这意味着Python会自动创建该名称的变量。 12345678910111213@suppressYade [1]: from yade import *\tYade [1]: O.engines=[\t...: NewtonIntegrator(damping=.2,label=&#x27;newtonCustomLabel&#x27;)\t...: ]\t...:Yade [1]: newtonCustomLabel.damping=.4Yade [1]: O.engines[0].damping # O.engines[0] and newtonCustomLabel are the same objectsYade [1]: newtonCustomLabel==O.engines[0] # O.engines[0] and newtonCustomLabel are the same objects Exercises 下列表达式的意义 1max([b.state.vel.norm() for b in O.bodies]) 运行脚本 gravity-deposition, 模拟几秒钟后暂停。编写计算表达式 kinetic energy $\\sum \\frac{1}{2} m_i |v_i| ^2$ average mass (hint: use numpy.average ) maximum $z$-coordinate of all particles number of interactions of body #1 Global data模拟过程中一些有用的数值。 unbalanced force 最大接触力与最大平均力之比;静力测量，用不平衡力计算 porosity 空隙体积与总容积之比; computed with porosity. coordination number 每个粒子的平均相互作用数,avgNumInteractions stress tensor (periodic boundary conditions) 相互作用的平均力, computed with normalShearStressTensors fabric tensor 空间接触的分布(尚未实施); 可通过plotDirections可视化 Energies对模拟中所有组件(如重力功、动能、塑料耗散、阻尼耗散)的 energy data 进行评估, 启用如下 1O.trackEnergy=True 其次, energy data 可以通过 O.energy访问; 它是一个字典，它的条目可以用keys()检索，其值可以用O.energy[key]检索。 SavePyRunner保存我们刚学会访问的数据, 我们需要从simulation loop 中调用Python。PyRunner就是为此而创建的;它从PeriodicEngine中继承了周期性控制，并将代码作为名为command的文本属性(必须加引号，即在&#39;…&#39;)运行。例如，在O.engines后面加上这个。引擎将打印当前的步数每一秒钟clokc time. 1O.engines=O.engines+[ PyRunner(command=&#x27;print(O.iter)&#x27;,realPeriod=1) ] 在command中编写复杂的代码是很尴尬的;在这种情况下，我们定义一个函数将被调用: 123456def myFunction(): &#x27;&#x27;Print step number, and pause the simulation is unbalanced force is smaller than 0.05.&#x27;&#x27;&#x27;\tprint(O.iter)\tif utils.unbalancedForce()&lt;0.05: print(&#x27;Unbalanced force is smaller than 0.05, pausing.&#x27;) O.pause() 现在，将函数添加至O.engines 1O.engines+=[PyRunner(command=&#x27;myFunction()&#x27;,iterPeriod=100)] 或者，通常像这样 1234O.engines=[\t# ...\tPyRunner(command=&#x27;myFunction()&#x27;,iterPeriod=100) # call myFunction every 100 steps ] 警告:: 如果在yade会话(ipython)中声明了一个函数，并且PyRunner属性updateGlobals被设置为False，则会出现错误NameError: name ‘myFunction’没有定义，除非python globals()用command更新 python1globals().update(locals()) 练习： 运行 gravity-deposition 模拟, 如下做出改变: 每隔两秒打印yade._utils.unbalancedForce . 每1000步检查一次unbalanced force 如果小于 0.2, 设置:damping 为0.8 (提示: 使用 labels) 如果小于0.1，则暂停模拟 Keeping historyYade提供了用于存储和绘制变量的plot模块(绘制本身将在后面讨论)。让我们从导入这个模块开始，并声明将要绘制的变量名: 12from yade import plotplot.plots=&#123;&#x27;t&#x27;:(&#x27;coordNum&#x27;,&#x27;unForce&#x27;,None,&#x27;Ek&#x27;)&#125; # kinetic energy will have legend on the right as indicated by None separator. 数据的定期存储是通过PyRunner和plot完成的。addData函数。同时让我们启用 energy tracking: 1234O.trackEnergy=Truedef addPlotData():\t# this function adds current values to the history of data, under the names specified\tplot.addData(t=O.time,Ek=utils.kineticEnergy(),coordNum=utils.avgNumInteractions(),unForce=utils.unbalancedForce()) 现在这个函数可以被添加至O.engines:: 1O.engines+=[PyRunner(command=&#x27;addPlotData()&#x27;,iterPeriod=20)] 或者，通常像这样 123O.engines=[ # ...,\tPyRunner(command=&#x27;addPlotData()&#x27;,iterPeriod=20) # call the addPlotData function every 20 iterations\t] 历史数据储存在yade.plot.data, 可以通过变量名称访问。例如plot.data[&#39;Ek&#39;]，可以通过yade.plot.saveDataTxt保存至txt文件（在yade外做后处理）。 Plotyade.plot提供了绘制被yade.plot.addData储存的历史数据 1plot.plots=&#123;&#x27;t&#x27;:(&#x27;coordNum&#x27;,&#x27;unForce&#x27;,None,&#x27;Ek&#x27;)&#125; 所有值的历史记录以yade.plot.addData的名称给出;字典的键值是x轴上的变量，变量按照顺序在y轴上。None分割左右轴的数据（独立缩放）。图表被创建如下 1plot.plot() # on the command line, F8 can be used as shorthand 当图表打开，会定期更新，以便实时看到模拟演变。 Energy plots绘制所有energy的contributions将是困难的，因为所有energy的名称可能无法事先知道。幸运的是，Yade有办法解决这个问题。它由两部分组成: yade.plot.addData 给出了目前定义的所有energy:: 1plot.addData(i=O.iter,total=O.energy.total(),**O.energy) O.energy.total 会计算所有energies 总和. **O.energy 是特殊的python语法, 将 dictionary (记住O.energy 是一个字典) 转变成命名函数的参数, 因此以下两个命令是相同的 12function(a=3,b=34) # give arguments as argumentsfunction(**&#123;&#x27;a&#x27;:3,&#x27;b&#x27;:34&#125;) # create arguments from dictionary 要绘制的数据使用 function 指定，该函数提供要绘制的数据的名称，而不是直接提供数据名称: 1plot.plots=&#123;&#x27;i&#x27;:[&#x27;total&#x27;]+O.energy.keys()&#125; 其中total是基于上面O.energy.total()的名称，O.energy.keys()将总是返回当前定义的energy列表。 Energy plot example在yade会话内部中绘制energies，例如启动examples/test/triax-basic-without-plots.py 将会如下所示 123456789101112from yade import plotO.trackEnergy=TrueO.step() # performing a single simulation step is necessary to populate O.energy.keys()plot.plots=&#123;&#x27;t&#x27;:O.energy.keys()+[&#x27;total&#x27;]&#125;def addPlotData():\t# this function adds current values to the history of data, under the names specified\tplot.addData( t=O.time , total=O.energy.total() , **O.energy )O.engines+=[PyRunner(command=&#x27;addPlotData()&#x27;,iterPeriod=20)]globals().update(locals()) # do this only because this is an example of a live yade session Press F8 to show plot window and F11 to show 3D view, then press ▶ to start simulation. Using multiple plots也可以制作独立绘图，例如 1plot.plots=&#123; &#x27;t&#x27;:(&#x27;total&#x27;,&#x27;kinetic&#x27;) , &#x27;t &#x27;:[&#x27;elastPotential&#x27;,&#x27;gravWork&#x27;] , &#x27;t &#x27;:(&#x27;nonviscDamp&#x27;) &#125; 警告在不同的plots中不能声明重复的名称。这就是为什么上面使用空格来表示相同的变量t。 With the caveat above, a following example inside a live yade session launched on examples/test/triax-basic-without-plots.py would look following:: 123456789101112131415from yade import plotO.trackEnergy=Trueplot.plots=&#123; &#x27;t&#x27;:(&#x27;total&#x27;,&#x27;kinetic&#x27;) , &#x27;t &#x27;:[&#x27;elastPotential&#x27;,&#x27;gravWork&#x27;] , &#x27;t &#x27;:(&#x27;nonviscDamp&#x27;) &#125;def addPlotData():\t# assign value to all three: &#x27;t&#x27;, &#x27;t &#x27; and &#x27;t &#x27; with single t=... assignment\tplot.addData( t=O.time , total=O.energy.total() , **O.energy )O.engines+=[PyRunner(command=&#x27;addPlotData()&#x27;,iterPeriod=20)]globals().update(locals()) # do this only because this is an example of a live yade sessionplot.plot(subPlots=False) # show plots in separate windowsplot.plot(subPlots=True) # same as pressing F8: close current plot windows and reopen a single new one Press F8 to show plot window and F11 to show 3D view, then press ▶ to start simulation, see video__ below: Exercises 计算y方向的平均动量. 运行 gravity-deposition 脚本, 绘制 unbalanced force 和 kinetic energy. 在脚本运行时, 尝试改变 NewtonIntegrator.damping 参数 (do it from both Inspector and from the command-line). 它对不平衡力和动能的演化有什么影响? 思考并写下所有的能源来源(输入);还要写下所有的能量消耗(耗散)。 模拟gravity-deposition 并绘制所有energies 在模拟过程中的变化。 注意Most :examples use plotting facilities of Yade, some of them also track energy of the simulation. https://yade-dem.org/doc/tutorial-data-mining.html","tags":["yade"]},{"title":"Hello World","path":"/2023/02/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]