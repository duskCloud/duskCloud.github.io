<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Sphere packings - duskCloud blog</title>

  
    <meta name="description" content="Sphere packings通过球体排列来表示任意形状的固体存在球体堆积问题，即球体的空间排列使得给定的实体近似地填充它们。出于 DEM 仿真的目的，可能有几个要求。  球体半径的分布。任意体积可以完全填充球体，前提是它们的半径没有限制;在这种情况下，球体的数量可以是无限的，它们的半径接近于零。由于粒子数量和最小球体半径（通过临界时间步长）决定了计算成本，因此必须强制给出半径分布。最典型的分布是">
<meta property="og:type" content="article">
<meta property="og:title" content="Sphere packings">
<meta property="og:url" content="https://duskcloud.github.io/2023/02/12/YadeTutorial/Sphere%20packings/index.html">
<meta property="og:site_name" content="duskCloud blog">
<meta property="og:description" content="Sphere packings通过球体排列来表示任意形状的固体存在球体堆积问题，即球体的空间排列使得给定的实体近似地填充它们。出于 DEM 仿真的目的，可能有几个要求。  球体半径的分布。任意体积可以完全填充球体，前提是它们的半径没有限制;在这种情况下，球体的数量可以是无限的，它们的半径接近于零。由于粒子数量和最小球体半径（通过临界时间步长）决定了计算成本，因此必须强制给出半径分布。最典型的分布是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yade-dem.org/doc/_images/hyperboloid.png">
<meta property="og:image" content="https://yade-dem.org/doc/_images/funnel.png">
<meta property="og:image" content="https://yade-dem.org/doc/_images/horse.png">
<meta property="og:image" content="https://yade-dem.org/doc/_images/predicate-difference.png">
<meta property="article:published_time" content="2023-02-12T12:25:05.225Z">
<meta property="article:modified_time" content="2023-02-12T12:27:05.825Z">
<meta property="article:author" content="duskCloud">
<meta property="article:tag" content="yade">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yade-dem.org/doc/_images/hyperboloid.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">duskCloud blog</div></a></div>

<nav class="menu dis-select"></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Sphere packings</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume-representation"><span class="toc-text">Volume representation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructive-Solid-Geometry-CSG"><span class="toc-text">Constructive Solid Geometry (CSG)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boundary-representation-BREP"><span class="toc-text">Boundary representation (BREP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean-operations-on-predicates"><span class="toc-text">Boolean operations on predicates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Packing-algorithms"><span class="toc-text">Packing algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geometric"><span class="toc-text">Geometric</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Regular"><span class="toc-text">Regular</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Irregular"><span class="toc-text">Irregular</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic"><span class="toc-text">Dynamic</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2023-02-12T12:25:05.225Z">2023-02-12</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>Sphere packings</span></h1>
<h1 id="Sphere-packings"><a href="#Sphere-packings" class="headerlink" title="Sphere packings"></a>Sphere packings</h1><p>通过球体排列来表示任意形状的固体存在球体堆积问题，即球体的空间排列使得给定的实体近似地填充它们。出于 DEM 仿真的目的，可能有几个要求。</p>
<ol>
<li>球体半径的分布。任意体积可以完全填充球体，前提是它们的半径没有限制;在这种情况下，球体的数量可以是无限的，它们的半径接近于零。由于粒子数量和最小球体半径（通过临界时间步长）决定了计算成本，因此必须强制给出半径分布。最典型的分布是均匀的：均值±离散;如果色散为零，则所有球体将具有相同的半径。</li>
<li>平滑边界。一些算法处理边界的方式是球体在其上对齐，使它们作为表面更平滑。</li>
<li>堆积密度，或球体体积与固体尺寸之比。它与半径分布密切相关。</li>
<li>协调数，每个球体的（平均）触点数。</li>
<li>各向同性（与规律性&#x2F;不规则性有关）;通常不希望具有首选方向的填料，除非建模的实体也具有这种偏好。</li>
<li>允许球体的重叠;某些算法可能会在球体略微重叠的地方创建堆积;由于重叠通常会在DEM中产生力，因此无重叠填料有时被称为“无应力”。</li>
</ol>
<h2 id="Volume-representation"><a href="#Volume-representation" class="headerlink" title="Volume representation"></a>Volume representation</h2><p>在Yade中，有两种方法可以表示所讨论的实体的精确体积：边界表示和构造实体几何。尽管它们存在根本差异，但它们在 Yade 中被抽象为 <code>Predicate</code> 类。 <code>Predicate</code>提供以下功能：</p>
<ol>
<li>为关联的实体定义轴对齐的边界框（可选地定义定向边界框）;</li>
<li>可以决定给定点是在实体内部还是外部;大多数谓词还可以（精确或近似地）判断点是否在内部，并满足与所表示的实体边界的某个给定填充距离（因此该体积的球体不会从实体中伸出）。</li>
</ol>
<h3 id="Constructive-Solid-Geometry-CSG"><a href="#Constructive-Solid-Geometry-CSG" class="headerlink" title="Constructive Solid Geometry (CSG)"></a>Constructive Solid Geometry (CSG)</h3><p>CSG方法通过几何 <em>基元(rimitives)</em> 或原始实体（球体，圆柱体，盒子，圆锥体等）来描述体积 以及对它们的布尔运算。Yade中定义的基元包括 <code>inCylinder</code>, <code>inSphere</code>, <code>inEllipsoid</code>, s<code>inHyperboloid</code>, <code>notInNotch</code>.<br>例如，用于拉伸压缩测试的<code>hyperboloid</code> （狗骨）试样可以这样构建（如img.img-hyperboloid_所示）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from yade import pack</span><br><span class="line"></span><br><span class="line">## construct the predicate first</span><br><span class="line">pred=pack.inHyperboloid(centerBottom=(0,0,-.1),centerTop=(0,0,.1),radius=.05,skirt=.03)</span><br><span class="line">## alternatively: pack.inHyperboloid((0,0,-.1),(0,0,.1),.05,.03)</span><br><span class="line"></span><br><span class="line">## pack the predicate with spheres (will be explained later)</span><br><span class="line">spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=3.5e-3)</span><br><span class="line"></span><br><span class="line">## add spheres to simulation</span><br><span class="line">O.bodies.append(spheres)</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://yade-dem.org/doc/_images/hyperboloid.png" alt="hyperboloid"></p>
<p>Specimen constructed with the <code>yade._packPredicates.inHyperboloid</code> predicate, packed with <code>yade.pack.randomDensePack</code>.</p>
<h3 id="Boundary-representation-BREP"><a href="#Boundary-representation-BREP" class="headerlink" title="Boundary representation (BREP)"></a>Boundary representation (BREP)</h3><p>通过边界表示实体比 CSG 体积灵活得多，但大多只是近似值。Yade与<a target="_blank" rel="noopener" href="http://gts.sourceforge.net/">GNU三角化曲面库</a>（GTS）接口，以导入GTS可读的曲面，但也可以从模拟脚本中显式构造它们。这使得相当复杂的形状的参数化构造成为可能;有一些函数可以从 2D 折线 (<code>yade.pack.revolutionSurfaceMeridians</code>) 创建一组 3D 折线，以在此类 3D 折线集 (<code>yade.pack.sweptPolylines2gtsSurface</code>). 之间对曲面进行三角测量。</p>
<p>例如，我们可以构建一个简单的漏斗 (<code>examples/funnel.py</code>, shown at img-funnel_)::</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from numpy import linspace</span><br><span class="line">from yade import pack</span><br><span class="line"></span><br><span class="line"># angles for points on circles</span><br><span class="line">thetas=linspace(0,2*pi,num=16,endpoint=True)</span><br><span class="line"></span><br><span class="line"># creates list of polylines in 3d from list of 2d projections</span><br><span class="line"># turned from 0 to π</span><br><span class="line">meridians=pack.revolutionSurfaceMeridians(</span><br><span class="line">        [[(3+rad*sin(th),10*rad+rad*cos(th)) for th in thetas] for rad in linspace(1,2,num=10)],</span><br><span class="line">        linspace(0,pi,num=10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># create surface</span><br><span class="line">surf=pack.sweptPolylines2gtsSurface(</span><br><span class="line">        meridians</span><br><span class="line">        +[[Vector3(5*sin(-th),-10+5*cos(-th),30) for th in thetas]]  # add funnel top</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># add to simulation</span><br><span class="line">O.bodies.append(pack.gtsSurface2Facets(surf))</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://yade-dem.org/doc/_images/funnel.png" alt="funnel"></p>
<p>Triangulated funnel, constructed with the <code>examples/funnel.py</code> script.</p>
<p>GTS 曲面对象可用于下面两项：</p>
<ol>
<li><code>yade.pack.gtsSurface2Facets</code>函数可在模拟中创建三角面(from <code>Facet</code> particles)，如例子漏斗所示.(三角面可直接由<code>yade.ymport.stl</code>从STL文件中导入)</li>
<li></li>
<li><code>yade._packPredicates.inGtsSurface</code> predicate can be created, 使用曲面作为封闭体积的边界表示。</li>
</ol>
<p>The <code>examples/gts-horse/gts-horse.py</code> (img. img-horse_)显示了两种可能性;首先，导入几何和拓扑结构曲面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import gts</span><br><span class="line">surf=gts.read(open(&#x27;horse.coarse.gts&#x27;))</span><br></pre></td></tr></table></figure>
<p>该面片对象用作packing的predicate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred=pack.inGtsSurface(surf)</span><br><span class="line">aabb=pred.aabb()</span><br><span class="line">radius=(aabb[1][0]-aabb[0][0])/40</span><br><span class="line">O.bodies.append(pack.regularHexa(pred,radius=radius,gap=radius/4.))</span><br></pre></td></tr></table></figure>
<p>然后，在平移后，作为模拟本身中三角化曲面的基础：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">surf.translate(0,0,-(aabb[1][2]-aabb[0][2]))</span><br><span class="line">O.bodies.append(pack.gtsSurface2Facets(surf,wire=True))</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://yade-dem.org/doc/_images/horse.png" alt="horse"></p>
<p>导入GTS面(horse) 作为 packing predicate(top) 和由<code>facets</code> (bottom)组成的面<br>See <a target="_blank" rel="noopener" href="http://www.youtube.com/watch?v=PZVruIlUX1A">video</a> for movie of this simulation.</p>
<h3 id="Boolean-operations-on-predicates"><a href="#Boolean-operations-on-predicates" class="headerlink" title="Boolean operations on predicates"></a>Boolean operations on predicates</h3><p>对predicates的bool运算 (注意 <code>A</code> 和 <code>B</code>) 定义如下:</p>
<ul>
<li><code>intersection</code> <code>A &amp; B</code> (conjunction): 点必须在涉及的两个predicates中。</li>
<li><code>union</code> <code>A | B</code> (disjunction): 点必须位于第一个predicate或第二个predicate中。</li>
<li><code>difference</code> <code>A - B</code> (conjunction with second predicate negated): 点必须在第一个predicate中，而不是在第二个predicate中.</li>
<li><code>symmetric difference</code> <code>A ^ B</code> (exclusive disjunction): 点必须恰好位于两个predicates之一中。</li>
</ul>
<p>组合 predicates 也需要正确定义边界框.例如，我们可以拿盒子并从内部移走圆柱体, 使用<code>A - B</code> 操作 (img. img-predicate-difference_)::</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)</span><br><span class="line">spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,returnSpherePack=True)</span><br><span class="line">spheres.toSimulation()</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://yade-dem.org/doc/_images/predicate-difference.png" alt="predicate-difference"><br>盒子从内部取出圆柱体，使用这两个predicates的差异。</p>
<h3 id="Packing-algorithms"><a href="#Packing-algorithms" class="headerlink" title="Packing algorithms"></a>Packing algorithms</h3><p>下面介绍的算法在几何球体上运行，由其中心和半径定义。除下面记录的一些例外情况外，该过程如下：</p>
<ol>
<li><p>计算球体位置和半径（有些函数为此使用volume predicate，有些则不使用）</p>
</li>
<li><p><code>sphere</code> 为每个位置和半径计算调用; 接收打包函数的额外关键字参数(<a target="_blank" rel="noopener" href="http://docs.python.org/glossary.html#term-keyword-argument%3E">keyword arguments</a>)（即打包函数未在其定义中指定的参数;它们被记录为 <code>**kw</code>）。每个<code>sphere</code>调用都会创建具有球体形状的实际 <code>Body</code> 对象。返回 <code>Body</code>对象的列表。</p>
</li>
<li><p>从打包函数返回的列表可以使用<code>toSimulation()</code>”添加到模拟中。剩余代码使用了对<code>O.bodies.append</code>的调用。</p>
</li>
</ol>
<p>以穿孔箱为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred=pack.inAlignedBox((-2,-2,-2),(2,2,2))-pack.inCylinder((0,-2,0),(0,2,0),1)</span><br><span class="line">spheres=pack.randomDensePack(pred,spheresInCell=2000,radius=.1,rRelFuzz=.4,wire=True,color=(0,0,1),material=1,returnSpherePack=True)</span><br></pre></td></tr></table></figure>
<p>关键字参数 <code>wire</code>, <code>color</code> 和<code>material</code> 未在 <code>yade.pack.randomDensePack</code>中声明, 因此将被传递到 <code>sphere</code>,并记录. <code>spheres</code> 现在是一个<code>SpherePack</code>对象::</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spheres.toSimulation()</span><br></pre></td></tr></table></figure>
<p>下面描述的包装算法会产生致密的填充。如果需要松散打包，<code>SpherePack</code>类通过其<code>makeCloud()</code> 方法提供用于生成松散打包的函数。它在内部用于在动态算法中生成初始配置。例如：：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from yade import pack</span><br><span class="line">sp=pack.SpherePack()</span><br><span class="line">sp.makeCloud(minCorner=(0,0,0),maxCorner=(3,3,3),rMean=.2,rRelFuzz=.5)</span><br></pre></td></tr></table></figure>
<p>将用球体填充给定的框，直到无法放置更多球体。该对象可用于向模拟中添加球体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.toSimulation()</span><br></pre></td></tr></table></figure>

<h3 id="Geometric"><a href="#Geometric" class="headerlink" title="Geometric"></a>Geometric</h3><p>几何算法计算packing，无需执行动态仿真;它们的优点包括：</p>
<ul>
<li>速度;</li>
<li>球体完全接触，没有重叠（有些人称之为”stress-free” packing）</li>
</ul>
<p>主要缺点是，除特定情况（常规填料）外，无法准确规定半径分布;球体半径由算法给出，该算法已经使系统确定。如果精确的半径分布对您的问题很重要，请考虑使用动态算法。</p>
<h4 id="Regular"><a href="#Regular" class="headerlink" title="Regular"></a>Regular</h4><p>Yade为具有恒定半径的球体定义了packing生成器，可以与上述volume predicates一起使用。它们是密集的正交填料（<code>yade.pack.regularOrtho</code>）和致密的六边形填料（<code>yade.pack.regularOrtho</code>）。后者创造了所谓的“六边形紧密填料”，实现了最大的密度（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Close-packing_of_spheres%EF%BC%89%E3%80%82">http://en.wikipedia.org/wiki/Close-packing_of_spheres）。</a></p>
<p>常规填料的明显缺点是它们具有非常强烈的方向偏好，这在某些情况下可能不是问题。</p>
<h4 id="Irregular"><a href="#Irregular" class="headerlink" title="Irregular"></a>Irregular</h4><p>随机几何算法不与上述volume predicates集成;相反，它们采用自己的边界&#x2F;体积定义，在球体定位期间使用。另一方面，这使得他们有可能重视边界，使球体在适当的位置接触边界，而不是在两者之间留下空白空间。<br>GenGeo<br>是使用 <a target="_blank" rel="noopener" href="http://www.launchpad.net/esys-particle">ESyS-Pparticle</a> 开发的用于打包生成的库（python 模块）。它通过随机插入具有给定半径范围的球体来创建包装。插入的球体彼此精确地接触，更重要的是，如果在其附近，它们也会接触边界。边界表示为 GenGeo库的特殊对象（球体、圆柱体、盒子、凸多面体等…）。因此，GenGeo不能与如上所述由 yade predicates表示的volume一起使用。</p>
<p>该模块生成的Packings可以直接通过<code>ymport.gengeo</code>导入，也可以通过<code>ymport.gengeoFile</code>从保存的文件中导入。有一个示例脚本示例&#x2F;test&#x2F;genCylLSM.py。GenGeo的完整文档可以在 <a target="_blank" rel="noopener" href="http://esys.geocomp.uq.edu.au/esys-particle_python_doc/current/pythonapi/html/index.html">ESyS文档网站</a> 上找到。</p>
<p>有 debian 软件包 esys-particle 和 python-demgengeo。</p>
<h3 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h3><p>随机密集包装的最通用算法由<code>yade.pack.randomDensePack</code>提供。非重叠球体的初始松散堆积是通过将它们随机放置在长方体体积中生成的，半径由请求的（目前仅均匀的）半径分布给出。当无法插入更多球体时，通过运行 DEM 模拟压缩填料，然后解压缩（有关这些“应力”的确切值，请参见<code>py/pack/pack.py</code>）; <code>Omega.switchScene</code> 用于不影响现有模拟）。最后，如上所述，使用提供的predicate裁剪生成的填料。</p>
<p>就其性质而言，此方法可能需要相对较长的时间;并且有2个规定可以缩短计算时间：</p>
<ul>
<li><p>如果使用<code>spheresInCell</code>参数指定了球体数，则仅创建具有周期边界的较小样本，然后重复以填充predicate。这可以提供低规律性的高质量填料，具体取决于<code>spheresInCell</code>参数（建议值为几千）。</p>
</li>
<li><p>提供<code>memoizeDb</code>数将使<code>yade.pack.randomDensePack</code>首先查看提供的文件（SQLite数据库）以用于具有类似参数的包装。成功后，只需从数据库中读取包装并返回即可。如果没有类似的预先存在的打包，则运行正常过程，并在返回之前将结果保存在数据库中，以便具有相同参数的后续调用将快速返回。<br>Providing <code>memoizeDb</code> parameter will make <code>yade.pack.randomDensePack</code><br>如果您需要获取完整的定期打包（而不是由predicate裁剪的打包），则可以使用<code>yade.pack.randomPeriPack</code>.</p>
</li>
</ul>
<p>如有特殊需求，您可以“手工”自己制作包装。例如，包装边界可以从<code>facets</code>构建，让空间中随机定位的球体在重力作用下落下。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">Older</div><a href="/2023/02/12/YadeTutorial/SettingUpASimulation/">Setting Up A Simulation</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
